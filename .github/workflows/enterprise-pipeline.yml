name: Enterprise CI/CD Pipeline - Advanced

on:
  push:
    branches: [main, master, develop, staging]
  pull_request:
    branches: [main, master, develop]
  schedule:
    - cron: '0 2 * * *'  # Daily security scans

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: item-exchange-app
  ECS_SERVICE: item-exchange-service
  ECS_CLUSTER: item-exchange-cluster
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}

jobs:
  # ==================== PIPELINE OPTIMIZATION ====================
  cache-dependencies:
    name: Cache Dependencies
    runs-on: ubuntu-latest
    outputs:
      backend-cache-key: ${{ steps.backend-cache.outputs.cache-hit }}
      frontend-cache-key: ${{ steps.frontend-cache.outputs.cache-hit }}
    steps:
      - uses: actions/checkout@v3
      
      - name: Cache Python dependencies
        id: backend-cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
      
      - name: Cache Node dependencies
        id: frontend-cache
        uses: actions/cache@v3
        with:
          path: frontend/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('frontend/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

  # ==================== ADVANCED SECURITY SCANNING ====================
  security-compliance:
    name: Security & Compliance Validation
    runs-on: ubuntu-latest
    needs: cache-dependencies
    strategy:
      matrix:
        scan-type: [secrets, licenses, vulnerabilities, compliance]
    steps:
      - uses: actions/checkout@v3
      
      - name: Secret Detection
        if: matrix.scan-type == 'secrets'
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
        continue-on-error: true
      
      - name: License Compliance Check
        if: matrix.scan-type == 'licenses'
        run: |
          pip install pip-licenses
          cd backend && pip-licenses --format=json --output-file=licenses.json
          cd ../frontend && npx license-checker --json --out licenses.json
        continue-on-error: true
      
      - name: GDPR Compliance Validation
        if: matrix.scan-type == 'compliance'
        run: |
          echo "Validating GDPR compliance..."
          grep -r "personal.*data\|email\|phone" . --include="*.py" --include="*.js" || true
          echo "Data encryption verification..."
          grep -r "encrypt\|hash" . --include="*.py" || true
        continue-on-error: true
      
      - name: Infrastructure Security Scan
        if: matrix.scan-type == 'vulnerabilities'
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          framework: dockerfile,terraform
        continue-on-error: true

  # ==================== COMPREHENSIVE TESTING ====================
  integration-tests:
    name: Integration & E2E Testing
    runs-on: ubuntu-latest
    needs: cache-dependencies
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      
      - name: API Integration Tests
        run: |
          cd backend
          pip install -r requirements.txt
          python -m pytest tests/integration/ -v --tb=short
        env:
          DATABASE_URL: postgresql://postgres:postgres@postgres:5432/test_db
          REDIS_URL: redis://redis:6379/0
        continue-on-error: true
      
      - name: E2E Tests with Cypress
        run: |
          cd frontend
          npm ci
          npm run build
          npx cypress run --headless
        continue-on-error: true

  # ==================== PERFORMANCE TESTING ====================
  performance-tests:
    name: Performance & Load Testing
    runs-on: ubuntu-latest
    needs: [cache-dependencies]
    steps:
      - uses: actions/checkout@v3
      
      - name: Load Testing with Artillery
        run: |
          npm install -g artillery
          artillery run tests/load/api-load-test.yml
        continue-on-error: true
      
      - name: Frontend Performance Audit
        run: |
          npm install -g lighthouse-ci
          cd frontend
          npm run build
          npx serve -s build &
          sleep 5
          lhci autorun
        continue-on-error: true

  # ==================== ADVANCED BUILD & OPTIMIZATION ====================
  optimized-build:
    name: Optimized Build & Push
    runs-on: ubuntu-latest
    needs: [security-compliance, integration-tests, performance-tests]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/staging'
    strategy:
      matrix:
        service: [backend, frontend]
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
        continue-on-error: true
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        continue-on-error: true
      
      - name: Build and push optimized images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            --push \
            -t $ECR_REGISTRY/$ECR_REPOSITORY-${{ matrix.service }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY-${{ matrix.service }}:latest \
            ./${{ matrix.service }}
        continue-on-error: true

  # ==================== CANARY DEPLOYMENT ====================
  canary-deployment:
    name: Canary Deployment
    runs-on: ubuntu-latest
    needs: optimized-build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment: production
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
        continue-on-error: true
      
      - name: Deploy Canary (10% traffic)
        run: |
          # Deploy canary version
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }}-canary \
            --force-new-deployment
          
          # Wait for deployment
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}-canary
        continue-on-error: true
      
      - name: Health Check & Metrics Validation
        run: |
          echo "Monitoring canary deployment metrics..."
          sleep 300  # Wait 5 minutes for metrics
          
          # Check error rate (should be < 1%)
          ERROR_RATE=$(aws cloudwatch get-metric-statistics \
            --namespace AWS/ApplicationELB \
            --metric-name HTTPCode_Target_5XX_Count \
            --start-time $(date -u -d '10 minutes ago' +%Y-%m-%dT%H:%M:%S) \
            --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
            --period 300 \
            --statistics Sum \
            --query 'Datapoints[0].Sum' \
            --output text)
          
          if [ "$ERROR_RATE" -gt "10" ]; then
            echo "High error rate detected: $ERROR_RATE"
            exit 1
          fi
        continue-on-error: true

  # ==================== AUTOMATED ROLLBACK ====================
  automated-rollback:
    name: Automated Rollback
    runs-on: ubuntu-latest
    needs: canary-deployment
    if: failure()
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
        continue-on-error: true
      
      - name: Rollback to Previous Version
        run: |
          # Get previous task definition
          PREVIOUS_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].deployments[1].taskDefinition' \
            --output text)
          
          # Rollback
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition $PREVIOUS_TASK_DEF
          
          echo "Rollback completed to: $PREVIOUS_TASK_DEF"
        continue-on-error: true
      
      - name: Send Rollback Notification
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"🚨 ROLLBACK EXECUTED: Production deployment failed and was automatically rolled back"}' \
            ${{ env.SLACK_WEBHOOK }}
        continue-on-error: true

  # ==================== COST ANALYSIS ====================
  cost-analysis:
    name: Cost Analysis & Optimization
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - uses: actions/checkout@v3
      
      - name: AWS Cost Analysis
        run: |
          # Get current month costs
          CURRENT_COST=$(aws ce get-cost-and-usage \
            --time-period Start=$(date +%Y-%m-01),End=$(date +%Y-%m-%d) \
            --granularity MONTHLY \
            --metrics BlendedCost \
            --group-by Type=DIMENSION,Key=SERVICE \
            --query 'ResultsByTime[0].Total.BlendedCost.Amount' \
            --output text)
          
          echo "Current month AWS cost: $CURRENT_COST USD"
          
          # Cost optimization recommendations
          echo "## Cost Optimization Report" > cost-report.md
          echo "- Current infrastructure cost: $CURRENT_COST USD" >> cost-report.md
          echo "- Recommendation: Use Spot instances for non-critical workloads" >> cost-report.md
          echo "- Recommendation: Implement auto-scaling policies" >> cost-report.md
        continue-on-error: true
      
      - name: Resource Utilization Analysis
        run: |
          # Check ECS service utilization
          aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].deployments[0].desiredCount' \
            --output text
          
          echo "Analyzing resource utilization patterns..."
        continue-on-error: true

  # ==================== NOTIFICATIONS ====================
  notifications:
    name: Pipeline Notifications
    runs-on: ubuntu-latest
    needs: [canary-deployment, cost-analysis]
    if: always()
    steps:
      - name: Success Notification
        if: needs.canary-deployment.result == 'success'
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"✅ DEPLOYMENT SUCCESS: Production deployment completed successfully"}' \
            ${{ env.SLACK_WEBHOOK }}
        continue-on-error: true
      
      - name: Failure Notification
        if: needs.canary-deployment.result == 'failure'
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"❌ DEPLOYMENT FAILED: Check pipeline logs for details"}' \
            ${{ env.SLACK_WEBHOOK }}
        continue-on-error: true